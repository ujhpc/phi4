\documentclass{beamer}
\usepackage{multirow}
\usepackage{listings}

\input {header.tex}
\renewcommand{\a}[1]{\v{a}_{#1}}
\renewcommand{\L}{\mathcal{L}}

\newcommand{\vphi}{\vec{\varphi}}
\newcommand{\vi}{{\vec{i}}}
\newcommand{\vj}{{\vec{j}}}
\newcommand{\vmu}{\vec{\mu}}

\newcommand{\redblack}[3]{ 
\pgfmathtruncatemacro{\odd}{Mod(#1+#2,2)}
   \ifnum \odd=0
      \fill[fill=black] (#1,#2) circle[radius=#3];
   \else
      \fill[fill=red] (#1,#2) circle[radius=#3];
   \fi
}


\newcommand{\fillblockgray}[2]{
\pgfmathtruncatemacro\llx{\bksize*(#1)-2}
\pgfmathtruncatemacro\lly{\bksize*(#2)-2}
\pgfmathtruncatemacro\urx{\bksize*(#1+1)+1}
\pgfmathtruncatemacro\ury{\bksize*(#2+1)+1}
\foreach \x in {\llx, ..., \urx}
  \foreach \y in {\lly,...,\ury} {
    \fill[gray] (\x, \y) circle(.25);
  }
}


\newcommand{\markpartition}[2]{
\pgfmathtruncatemacro\llx{\bksize*(#1)}
\pgfmathtruncatemacro\lly{\bksize*(#2)}
\pgfmathtruncatemacro\urx{\bksize*(#1+1)-1}
\pgfmathtruncatemacro\ury{\bksize*(#2+1)-1}
\foreach \x in {\llx, ..., \urx}
  \foreach \y in {\lly,...,\ury} {
    \partition{\x}{\y}{0.25}
  }
}


\newcommand{\partition}[3]{
\pgfmathtruncatemacro\lchalf{\bksize / 2}
      \pgfmathtruncatemacro\my{Mod(#1, 2)}
      \ifnum \my = 0
        \pgfmathtruncatemacro\ny{Mod(#1, 4)}
        \ifnum \ny = 2
          \pgfmathtruncatemacro\mx{Mod(#2+2, 4)}
        \else
          \pgfmathtruncatemacro\mx{Mod(#2, 4)}
        \fi
        \ifnum \mx = 0
            \fill[red] (#2, #1) circle(#3);
          \fi
         \fi
         
        }


\definecolor{colorone}{HTML}{006633} % default 116699
\definecolor{colortwo}{HTML}{DDFF99} % default CCCCCC
\def\bksize{8}
\def\bkcount{4}
\def\lcsize{5}

\lstset{basicstyle=\small}


\title{Monte-Carlo simulations of Ginzburg-Landau model on GPU}
\subtitle{with comparison with CPU}
\date{1 March 2013}
\author{Piotr Bialas}
\institute{Faculty of Physics, Astronomy and Computer Science, Jagiellonian University\\
Department of Game Technology}
\begin{document}

\begin{frame}
\titlepage
\vfill
J.~Kowal, A.~Strzelecki
\end{frame}



\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{The model}


\begin{frame}
\frametitle{Ginsburg-Landau model ($\vphi^4$)}
\begin{equation*}\label{eq:ham}\begin{split}
H[\varphi]&=\sum_{\vi}\Biggl(
\frac{1}{2}\sum_{\mu=1}^d(\vphi(x_\vi+\a{\mu})-\vphi(x_\vi))^2\\
&\phantom{=\sum_{\vi}\bigl(}+\frac{\mu^2}{2}|\vphi(x_{\vi})|^2+
\frac{g}{24}(|\vphi(x_{\vi})|^2)^2\\
&\phantom{=\sum_{\vi}\bigl(}+
\frac{1}{2\Lambda}\Bigl(\sum_{\mu=1}^d
(\vphi(x_\vi+\a{\mu})-2\vphi(x_{\vi})+\vphi(x_\vi-\a\mu))\Bigr)^2\Biggr).
\end{split}
\end{equation*}
\end{frame}


\begin{frame}
\frametitle{Ginsburg-Landau model ($\vphi^4$) }
\begin{tikzpicture} 
%\pgfmathtruncatemacro\lcsize{\bksize * \bkcount}
\def\lcsize{8}
\pgfmathtruncatemacro\lcsizem{\lcsize - 1}
\pgfmathtruncatemacro\lcsizeb{\lcsize - \bksize}
\pgfmathtruncatemacro\bksizea{\bksize - 2}
\pgfmathtruncatemacro\bksizeb{\bksize - 1}
\pgfmathtruncatemacro\bksizec{\bksize * 2}
\pgfmathtruncatemacro\bksizem{\bksizec - 1}
\pgfmathtruncatemacro\bksized{\bksizec + 1}
\draw[very thin, gray] (-.5, -.5) grid (\bksize - .5, \bksize - .5);
\foreach \x in {0,...,\lcsizem} 
\foreach \y in {0, ...,\lcsizem}
\draw[fill=white,draw=black]  (\x, \y) circle[radius=0.1];

\coordinate (c) at (4,4);

\node at (c)  [circle,fill=red,draw=black] {};

\def\coronaa{(0,1), (0,-1), (1,0), (-1,0)}
\def\coronab{(0,2), (0,-2), (2,0), (-2,0)}
\def\coronac{(1,1), (1,-1), (-1,-1), (-1,1)}

\foreach \p in \coronaa {
\path (c) +\p node  [circle,fill=gray]    {};
}

\foreach \p in \coronab {
\path (c) +\p node  [circle,fill=gray]    {};
}

\foreach \p in \coronac {
\path (c) +\p node  [circle,fill=gray]    {};
}


\end{tikzpicture}

\end{frame}

\begin{frame}
\frametitle{Parallel partitions}
\begin{tikzpicture}[scale=0.75]

% \clip[rounded corners=0cm] (-1, -1) rectangle (\bksize + 1, \bksize + 1);

% \draw[help lines] (-1, -1) grid (\bksize + 1, \bksize + 1);

\pgfmathtruncatemacro\bksizem{\bksize - 1}

% % lattice points
 \foreach \x in {0, ..., \bksizem}
   \foreach \y in {0, ..., \bksizem} {
     \pgfmathtruncatemacro\four{Mod(\y,4)}
     \pgfmathtruncatemacro\eight{Mod(\x,4)+4*Mod(\y,2)}
     \ifnum \four<2
     \pgfmathtruncatemacro\eight{Mod(\x,4)+4*Mod(\y,2)}
     \node[draw,rectangle,minimum size=0.6cm] at (\x,\y)  {\eight};
     \else
     \pgfmathtruncatemacro\eight{Mod(\x+2,4)+4*Mod(\y,2)}
     \node[draw,rectangle,minimum size=0.6cm] at (\x,\y)  {\eight};
     \fi
}
% neighborhood
\def\neighborhood{--
  ++( 0,  -.5)-- ++( 1,  0)-- ++( 0, -.5 )-- ++(0, -.5)-- ++( 1, 0  )--
  ++( 0, -1.0)-- ++( 1,  0)-- ++( 0,  1.0)-- ++(1, 0  )-- ++( 0, 1.0)--
  ++( 1,  0  )-- ++( 0,  1)-- ++(-1,  0  )-- ++(0, 1  )-- ++(-1, 0  )--
  ++( 0,  1  )-- ++(-1,  0)-- ++( 0, -1  )--
  ++(-1,  0  )-- ++( 0, -1)-- ++(-1,  0  )-- ++(0, -.6)}

\pgfmathtruncatemacro\lchalf{\bksize / 2}


% main center neighborhood
\path[draw=red,  rounded corners=.1cm, shorten >=2pt, line width=.75mm]
(\lchalf - 2.5, \lchalf) \neighborhood;

\end{tikzpicture}

\end{frame}



\section{CUDA implementation}

\begin{frame}
\frametitle{CUDA architecture -- SIMT}
\begin{itemize}
\item Logically CUDA program is run as a collection of concurrent {\em threads}.
\item Every thread is executing same program called {\em kernel}.
\item Smallest execution unit is 32 threads that make up a warp.
\item Threads are grouped in thread blocks.
\item Threads are run on scalar processors (CUDA cores). 
\item There should
      be much more threads then cores.
\end{itemize}
\end{frame}




\begin{frame}
\frametitle{Memory hierarchy}
\begin{itemize}
\item Registers. 
\item Max throughput
\begin{itemize}
\item 32 FMAD per cycle
\begin{itemize}
\item 12 bytes in 4 bytes out
\item 12x 32x15x1401MHz
\item 8.07 TB/s in 2.67 TB/s out
\end{itemize}
\end{itemize}
\item Shared memory
\begin{itemize}
\item 4 x 32 x 15 x 1401MHz/2 = 1.3TB/s
\end{itemize}
\item Global memory
\begin{itemize}
\item 156GB/s
\end{itemize}
\end{itemize}

\end{frame}


\begin{frame}

\begin{tikzpicture}[scale=0.25]

\pgfmathtruncatemacro\lcsize{\bksize * \bkcount}
\pgfmathtruncatemacro\lcsizem{\lcsize - 1}
\pgfmathtruncatemacro\lcsizeb{\lcsize - \bksize}
\pgfmathtruncatemacro\bksizea{\bksize - 2}
\pgfmathtruncatemacro\bksizeb{\bksize - 1}
\pgfmathtruncatemacro\bksizec{\bksize * 2}
\pgfmathtruncatemacro\bksizem{\bksizec - 1}
\pgfmathtruncatemacro\bksized{\bksizec + 1}

\draw[very thin, gray] (-.5, -.5) grid (\lcsize - .5, \lcsize - .5);

\foreach \x in {0, \bksize, ..., \lcsizeb}
  \foreach \y in {0, \bksize, ..., \lcsizeb} {
    \pgfmathtruncatemacro\n{Mod(\x/\bksize, 2)+2 * Mod(\y/\bksize, 2)+1}
    \draw[colorone, xshift=\x cm, yshift=\y cm, rounded corners=2pt]
      (-.4, -.4) rectangle
      node[red, fill opacity=.5, anchor=center, font=\Huge\bfseries\sffamily]
      {\n} (\bksize - .6, \bksize - .6);
  }

\foreach \x in {0, ..., \lcsizem}
  \foreach \y in {0, ..., \lcsizem}{
 
    \path[draw=black, fill=white] (\x, \y) circle(.25);
}

% \foreach \x in {\bksizea, ..., \bksized}
%   \foreach \y in {\bksizea,...,\bksized} {
%     \fill[gray] (\x, \y) circle(.25);
%     \fill[gray] (\y, \x) circle(.25);
%   }

\fillblockgray{0}{0}
\markpartition{0}{0}
\fillblockgray{0}{2}
\fillblockgray{2}{0}
\fillblockgray{2}{2}


}


\end{tikzpicture}

\tiny M.~Weigel, J.~Comput.~Phys. 231 (2012) 3064.
\end{frame}


\section{CPU implementation}

\begin{frame}
\frametitle{CPU}
\begin{itemize}
\item First measurments shoved over 300 fold  performance increase over CPU!
\item Not fair.
\item Compared to a non--parallel program.
\end{itemize}
\end{frame}



\begin{frame}
\frametitle{CPU implementation}
\begin{itemize}
\item We use same structure as on GPU.
\item We use OpenMP to distribute lattice blocks across cores.
\item In each block we use SSE instructions to proces 4 or 8 lattice points in parallel. 
\end{itemize}
\end{frame}


\begin{frame}

\begin{tikzpicture}[scale=0.25]

\pgfmathtruncatemacro\lcsize{\bksize * \bkcount}
\pgfmathtruncatemacro\lcsizem{\lcsize - 1}
\pgfmathtruncatemacro\lcsizeb{\lcsize - \bksize}
\pgfmathtruncatemacro\bksizea{\bksize - 2}
\pgfmathtruncatemacro\bksizeb{\bksize - 1}
\pgfmathtruncatemacro\bksizec{\bksize * 2}
\pgfmathtruncatemacro\bksizem{\bksizec - 1}
\pgfmathtruncatemacro\bksized{\bksizec + 1}

\draw[very thin, gray] (-.5, -.5) grid (\lcsize - .5, \lcsize - .5);

\foreach \x in {0, \bksize, ..., \lcsizeb}
  \foreach \y in {0, \bksize, ..., \lcsizeb} {
    \pgfmathtruncatemacro\n{Mod(\x/\bksize, 2)+2 * Mod(\y/\bksize, 2)+1}
    \draw[colorone, xshift=\x cm, yshift=\y cm, rounded corners=2pt]
      (-.4, -.4) rectangle
      node[red, fill opacity=.5, anchor=center, font=\Huge\bfseries\sffamily]
      {\n} (\bksize - .6, \bksize - .6);
  }

\foreach \x in {0, ..., \lcsizem}
  \foreach \y in {0, ..., \lcsizem}{
 
    \path[draw=black, fill=white] (\x, \y) circle(.25);
}

\foreach \x in {\bksizea, ..., \bksized}
  \foreach \y in {\bksizea,...,\bksized} {
    \fill[gray] (\x, \y) circle(.25);
    \fill[gray] (\y, \x) circle(.25);
  }


\foreach \x in {\bksize, ..., \bksizem}
  \foreach \y in {\bksize, ..., \bksizem} {
 \partition{\x}{\y}{0.25}
}


\end{tikzpicture}
\end{frame}



\begin{frame}
\frametitle{SSE}

Adm: tutaj pare zdan na temat twojej implementacji class SSE
\end{frame}



\begin{frame} 

\frametitle{Performance}
\definecolor{colorone}{HTML}{FFFFFF}
\definecolor{colortwo}{HTML}{991111}


\begin{center}
\def\arraystretch{1.1}%
\setlength{\tabcolsep}{1em}
\large
\begin{tabular}{ r r r | r }
    Size   & GPU\footnotemark & CPU\footnotemark & Boost \\
  \hline
   $32^3$  &  $1.262 ns$  &  $3.875 ns$  &  $3.070 \times$ \\
   $64^3$  &  $0.165 ns$  &  $3.094 ns$  & $18.751 \times$ \\
  $128^3$  &  $0.125 ns$  &  $3.311 ns$  & $26.488 \times$ \\
  $256^3$  &  $0.113 ns$  &  $3.332 ns$  & $29.486 \times$
\end{tabular}
\end{center}
\vfill
\small
$^1$\emph{GeForce GTX 470} 1.67 Ghz, 1.25GB, 448 CUDA cores, 2.0 capability\\
$^2$\emph{Intel Core i5-2400S CPU} 2.50 GHz, 4 core, 6MB Cache, SSE4.x/AVX

\end{frame}




\begin{frame} 
\begin{center}
\def\arraystretch{1.1}%
\setlength{\tabcolsep}{1em}
\large
\begin{tabular}{ r r r }
  Type      &     GPU      &  CPU \\
  \hline
  gather    &  $14.19 \%$  &  \multirow{2}{*}{$35.10 \%$} \\
  corona    &  $22.84 \%$  &  \\
  RNG       &  $ 6.66 \%$  &  $22.37 \%$ \\
  exp/log   &  $23.86 \%$  &  $10.02 \%$ \\
  update    &  $25.75 \%$  &  $32.51 \%$
\end{tabular}
\end{center}


\definecolor{colorone}{HTML}{006633}
\definecolor{colortwo}{HTML}{DDFF99}
\end{frame}


\section{Conclusions}

\begin{frame}
\frametitle{Conclusions}
\begin{itemize}
\item GPU is more efficient: runs closer to the peak.
\begin{itemize}
\item This is possible thanks to the use of shared memory. Just
  counting on cache is not enough.
\item This also takes care of indexing.
\end{itemize}
\item The CUDA execution model can be ported to CPU.
\begin{itemize}
\item There is no shared memory only cache.
\item There are no gather/scatter vector operations.
\item Not all the  operators have vector counterparts (e.g.integer operations in AVX).
\item All this is availble(?) on Xeon $\phi$. Is Cyfronet plannig to install some ? 
\end{itemize}
\end{itemize}
\end{frame}


\end{document}
