\documentclass{beamer}
\usepackage{multirow}
\usepackage{listings}

\input {header.tex}
\renewcommand{\a}[1]{\v{a}_{#1}}
\renewcommand{\L}{\mathcal{L}}

\newcommand{\vphi}{\vec{\varphi}}
\newcommand{\vi}{{\vec{i}}}
\newcommand{\vj}{{\vec{j}}}
\newcommand{\vmu}{\vec{\mu}}

\newcommand{\redblack}[3]{ 
\pgfmathtruncatemacro{\odd}{Mod(#1+#2,2)}
   \ifnum \odd=0
      \fill[fill=black] (#1,#2) circle[radius=#3];
   \else
      \fill[fill=red] (#1,#2) circle[radius=#3];
   \fi
}

\definecolor{colorone}{HTML}{006633} % default 116699
\definecolor{colortwo}{HTML}{DDFF99} % default CCCCCC
\def\bksize{8}
\def\bkcount{4}
\def\lcsize{5}

\lstset{basicstyle=\small}


\title{Graphic Processing Units in Lattice Field Theories}
%\subtitle{Wyk≈Çad 2}
\date{19 November 2012}
\begin{document}

\begin{frame}
\titlepage
\vfill
J.~Kowal, A.~Strzelecki
\end{frame}



\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{The model}




\begin{frame}
\frametitle{Ginsburg-Landau model ($\phi^4$)}
\begin{equation*}\label{eq:ham}\begin{split}
H[\varphi]&=\sum_{\vi}\Biggl(
\frac{1}{2}\sum_{\mu=1}^d(\vphi(x_\vi+\a{\mu})-\vphi(x_\vi))^2\\
&\phantom{=\sum_{\vi}\bigl(}+\frac{\mu^2}{2}|\vphi(x_{\vi})|^2+
\frac{g}{24}(|\vphi(x_{\vi})|^2)^2\\
&\phantom{=\sum_{\vi}\bigl(}+
\frac{1}{2\Lambda}\Bigl(\sum_{\mu=1}^d
(\vphi(x_\vi+\a{\mu})-2\vphi(x_{\vi})+\vphi(x_\vi-\a\mu))\Bigr)^2\Biggr).
\end{split}
\end{equation*}
\end{frame}


\begin{frame}
\frametitle{Ginsburg-Landau model ($\phi^4$) }
\begin{tikzpicture} 
%\pgfmathtruncatemacro\lcsize{\bksize * \bkcount}
\def\lcsize{8}
\pgfmathtruncatemacro\lcsizem{\lcsize - 1}
\pgfmathtruncatemacro\lcsizeb{\lcsize - \bksize}
\pgfmathtruncatemacro\bksizea{\bksize - 2}
\pgfmathtruncatemacro\bksizeb{\bksize - 1}
\pgfmathtruncatemacro\bksizec{\bksize * 2}
\pgfmathtruncatemacro\bksizem{\bksizec - 1}
\pgfmathtruncatemacro\bksized{\bksizec + 1}
\draw[very thin, gray] (-.5, -.5) grid (\bksize - .5, \bksize - .5);
\foreach \x in {0,...,\lcsizem} 
\foreach \y in {0, ...,\lcsizem}
\draw[fill=white,draw=black]  (\x, \y) circle[radius=0.1];

\coordinate (c) at (4,4);

\node at (c)  [circle,fill=red,draw=black] {};

\def\coronaa{(0,1), (0,-1), (1,0), (-1,0)}
\def\coronab{(0,2), (0,-2), (2,0), (-2,0)}
\def\coronac{(1,1), (1,-1), (-1,-1), (-1,1)}

\foreach \p in \coronaa {
\path (c) +\p node  [circle,fill=gray]    {};
}

\foreach \p in \coronab {
\path (c) +\p node  [circle,fill=gray]    {};
}

\foreach \p in \coronac {
\path (c) +\p node  [circle,fill=gray]    {};
}


% \node at (2,0)  [circle,fill=gray,draw=black] {};
% \node at (2,4)  [circle,fill=gray,draw=black] {};
% \node at (0,2)  [circle,fill=gray,draw=black] {};
% \node at (4,2)  [circle,fill=gray,draw=black] {};

% \node at (3,3)  [circle,fill=gray,draw=black] {};
% \node at (1,1)  [circle,fill=gray,draw=black] {};
% \node at (3,1)  [circle,fill=gray,draw=black] {};
% \node at (1,3)  [circle,fill=gray,draw=black] {};


\end{tikzpicture}

\end{frame}

\begin{frame}
\begin{tikzpicture}[scale=0.75]

% \clip[rounded corners=0cm] (-1, -1) rectangle (\bksize + 1, \bksize + 1);

% \draw[help lines] (-1, -1) grid (\bksize + 1, \bksize + 1);

\pgfmathtruncatemacro\bksizem{\bksize - 1}

% % lattice points
 \foreach \x in {0, ..., \bksizem}
   \foreach \y in {0, ..., \bksizem} {
     \pgfmathtruncatemacro\four{Mod(\y,4)}
     \pgfmathtruncatemacro\eight{Mod(\x,4)+4*Mod(\y,2)}
     \ifnum \four<2
     \pgfmathtruncatemacro\eight{Mod(\x,4)+4*Mod(\y,2)}
     \node[draw,rectangle,minimum size=0.6cm] at (\x,\y)  {\eight};
     \else
     \pgfmathtruncatemacro\eight{Mod(\x+2,4)+4*Mod(\y,2)}
     \node[draw,rectangle,minimum size=0.6cm] at (\x,\y)  {\eight};
     \fi
}
% neighborhood
\def\neighborhood{--
  ++( 0,  -.5)-- ++( 1,  0)-- ++( 0, -.5 )-- ++(0, -.5)-- ++( 1, 0  )--
  ++( 0, -1.0)-- ++( 1,  0)-- ++( 0,  1.0)-- ++(1, 0  )-- ++( 0, 1.0)--
  ++( 1,  0  )-- ++( 0,  1)-- ++(-1,  0  )-- ++(0, 1  )-- ++(-1, 0  )--
  ++( 0,  1  )-- ++(-1,  0)-- ++( 0, -1  )--
  ++(-1,  0  )-- ++( 0, -1)-- ++(-1,  0  )-- ++(0, -.6)}

\pgfmathtruncatemacro\lchalf{\bksize / 2}


% main center neighborhood
\path[draw=red,  rounded corners=.1cm, shorten >=2pt, line width=.75mm]
(\lchalf - 2.5, \lchalf) \neighborhood;

\end{tikzpicture}

\end{frame}


\begin{frame}

\begin{tikzpicture}[scale=0.5]
\begin{scope}[scale=0.66]
\draw[very thin, gray] (-0.5,-0.5) grid (15.5,15.5);

\foreach \x in {0,4,...,12}
  \foreach \y in {0,4,...,12}
    \draw[black,xshift=\x cm, yshift=\y cm, rounded corners = 2pt] (-.4,-0.4)
      rectangle (3.4cm,3.4cm);

\foreach \x in {0,...,15}
  \foreach \y in {0,...,15}
    \path[draw=black,fill=white] (\x, \y) circle(0.25);

\foreach \x in {0,8}
  \foreach \y in {0,8}
    \draw[xshift=\x cm, yshift=\y cm]
      node[black,fill opacity=0.3,scale=4,font=\bfseries\sffamily] at (1.5cm,1.5) {1}
      node[black,fill opacity=0.3,scale=4,font=\bfseries\sffamily] at (5.5cm,1.5) {2}
      node[black,fill opacity=0.3,scale=4,font=\bfseries\sffamily] at (1.5cm,5.5) {3}
      node[black,fill opacity=0.3,scale=4,font=\bfseries\sffamily] at (5.5cm,5.5) {4} ;

\foreach \x in {4,...,7}
  \foreach \y in {4,...,7}
    \fill[black] (\x, \y) circle(0.25);

\foreach \x in {4,...,7}
  \foreach \y in {2,3,8,9} {
    \fill[gray] (\x,\y) circle(0.25);
    \fill[gray] (\y,\x) circle(0.25);
  }

\foreach \p in {(3,3),(3,8),(8,3),(8,8)}
  \fill[gray] \p circle(0.25);

\end{scope}

\begin{scope}[xshift=14.5cm,yshift=3cm]
\clip (-3,-3) rectangle (7,7);

\draw[help lines] (-3.0,-3.0) grid (7.0,7.0);

% lattice points
\foreach \x in {-2,-1,0,1,2,3,4,5,6}
  \foreach \y in {-2,-1,0,1,2,3,4,5,6}
    \draw (\x,\y) + (0.0,0.0) circle (0.16);

% neighborhood
\foreach \p in {(-2.5,4.0),(1.5,4.0),
                (-2.5,0.0),(1.5,0.0),
                (-4.5,2.0),(3.5,2.0),
                (-4.5,6.0),(-0.5,6.0),(3.5,6.0),
                (-4.5,-2.0),(-0.5,-2.0),(3.5,-2.0)}
  \path[draw=black,fill,fill opacity=0.2,rounded corners=0.1cm,shorten >=2pt] \p \neighborhood;

% main center neighborhood

\path[draw=black,fill,fill opacity=0.4,rounded corners=0.1cm,shorten >=2pt,line width=0.75mm,cap=round,join=round] (-0.5,2.0) \neighborhood;

\foreach \p in {
  (-2, 2),( 2, 2),( 6, 2),
  ( 0, 4),( 0, 0),( 4, 0),( 4, 4),
  (-2,-2),( 2,-2),( 6,-2),
  (-2, 6),( 2, 6),( 6, 6)}
  \fill[black] \p circle(0.16);

\end{scope}

\end{tikzpicture}
\end{frame}

\section{CUDA Architecture}

\begin{frame}
\frametitle{CUDA architecture -- SIMT}
\begin{itemize}
\item Logically CUDA program is run as a collection of concurrent {\em threads}.
\item Every thread is executing same program called {\em kernel}.
\item Smallest execution unit is 32 threads that make up a warp.
\item Threads are grouped in thread blocks.
\item Threads are run on scalar processors (CUDA cores). 
\item There should
      be much more threads then cores.
\end{itemize}
\end{frame}




\begin{frame}
\frametitle{Memory hierarchy}
\begin{itemize}
\item Max throughput
\begin{itemize}
\item 32 FMAD per cycle
\begin{itemize}
\item 12 bytes in 4 bytes out
\item 12x 32x15x1401MHz
\item 8.07 TB/s in 2.67 TB/s out
\end{itemize}
\end{itemize}
\item Registers can sustain it.
\item Shared memory
\begin{itemize}
\item 4 x 32 x 15 x 1401MHz/2 = 1.3TB/s
\end{itemize}
\item Global memory
\begin{itemize}
\item 156GB/s
\end{itemize}
\end{itemize}

\end{frame}


\begin{frame}

\begin{tikzpicture}[scale=0.25]

\pgfmathtruncatemacro\lcsize{\bksize * \bkcount}
\pgfmathtruncatemacro\lcsizem{\lcsize - 1}
\pgfmathtruncatemacro\lcsizeb{\lcsize - \bksize}
\pgfmathtruncatemacro\bksizea{\bksize - 2}
\pgfmathtruncatemacro\bksizeb{\bksize - 1}
\pgfmathtruncatemacro\bksizec{\bksize * 2}
\pgfmathtruncatemacro\bksizem{\bksizec - 1}
\pgfmathtruncatemacro\bksized{\bksizec + 1}

\draw[very thin, gray] (-.5, -.5) grid (\lcsize - .5, \lcsize - .5);

\foreach \x in {0, \bksize, ..., \lcsizeb}
  \foreach \y in {0, \bksize, ..., \lcsizeb} {
    \pgfmathtruncatemacro\n{Mod(\x/\bksize, 2)+2 * Mod(\y/\bksize, 2)+1}
    \draw[colorone, xshift=\x cm, yshift=\y cm, rounded corners=2pt]
      (-.4, -.4) rectangle
      node[red, fill opacity=.5, anchor=center, font=\Huge\bfseries\sffamily]
      {\n} (\bksize - .6, \bksize - .6);
  }

\foreach \x in {0, ..., \lcsizem}
  \foreach \y in {0, ..., \lcsizem}{
 
    \path[draw=black, fill=white] (\x, \y) circle(.25);
}
\foreach \x in {\bksize, ..., \bksizem}
  \foreach \y in {\bksize, ..., \bksizem} {
 \redblack{\x}{\y}{0.25}
}
\foreach \x in {\bksize, ..., \bksizem}
  \foreach \y in {\bksizeb, \bksizec} {
    \fill[gray] (\x, \y) circle(.25);
    \fill[gray] (\y, \x) circle(.25);
  }


\end{tikzpicture}
\end{frame}

\section{CPU}

\begin{frame}
\frametitle{CPU}
\begin{itemize}
\item First measurments shoved over 300 fold  performance increase over CPU!
\item Not fair.
\item Compared to a non--parallel program.
\end{itemize}
\end{frame}



\begin{frame}[fragile]
\frametitle{OpenMP}
\begin{lstlisting}
#pragma parallel for
for(int i=0;i<n_points/2;i++) 
   update_red(i);

#pragma parallel for
for(int i=0;i<n_points/2;i++) 
   update_black(i);
\end{lstlisting}
\begin{itemize}
\item Distributing updates between cores/threads. 
\item Supported by all compilers. 
\end{itemize}

\end{frame}



\begin{frame}
\frametitle{SSE/AVX}
\begin{itemize}
\item Modern Intel and AMD processors have vector operations.
\begin{itemize} 
\item Streaming Side Extension  (SSE) Four single precision operations.
\item Advanced Vector Extensions (AVX) Eight  single precision operations.
\item Xeon $\phi$ 16  singleprecision operations.
\end{itemize}
\end{itemize}
\end{frame}



\begin{frame}
\frametitle{SSE/AVX}
\begin{itemize}
\item Programming  with vector operations can be done
\begin{itemize}
\item Asembler :)
\item Instrinsincs
\item Vector types
\item Compiler directives (Intel 13)
\end{itemize}
\end{itemize}
\end{frame}




\begin{frame} 

\frametitle{Performance}
\definecolor{colorone}{HTML}{FFFFFF}
\definecolor{colortwo}{HTML}{991111}


\begin{center}
\def\arraystretch{1.1}%
\setlength{\tabcolsep}{1em}
\large
\begin{tabular}{ r r r | r }
    Size   & GPU\footnotemark & CPU\footnotemark & Boost \\
  \hline
   $32^3$  &  $1.262 ns$  &  $4.316 ns$  &  $3.419 \times$ \\
   $64^3$  &  $0.165 ns$  &  $4.857 ns$  & $29.436 \times$ \\
  $128^3$  &  $0.125 ns$  &  $5.444 ns$  & $43.552 \times$ \\
  $256^3$  &  $0.113 ns$  &  $7.099 ns$  & $62.823 \times$
\end{tabular}
\end{center}
\vfill
\small
$^1$\emph{GeForce GTX 470} 1.67 Ghz, 1.25GB, 448 CUDA cores, 2.0 capability\\
$^2$\emph{Intel Core i5-2400S CPU} 2.50 GHz, 4 core, 6MB Cache, SSE4.x/AVX

\end{frame}




\begin{frame} 
\begin{center}
\def\arraystretch{1.1}%
\setlength{\tabcolsep}{1em}
\large
\begin{tabular}{ r r r }
  Type      &     GPU      &  CPU \\
  \hline
  gather    &  $14.19 \%$  &  \multirow{2}{*}{$59.73 \%$} \\
  corona    &  $22.84 \%$  &  \\
  RNG       &  $ 6.66 \%$  &  $13.88 \%$ \\
  exp/log   &  $23.86 \%$  &  $ 6.22 \%$ \\
  update    &  $25.75 \%$  &  $20.17 \%$
\end{tabular}
\end{center}


\definecolor{colorone}{HTML}{006633}
\definecolor{colortwo}{HTML}{DDFF99}
\end{frame}


\section{Conclusions}

\begin{frame}
\frametitle{Conclusions}
\begin{itemize}
\item Efficient use of  modern processors (CPU and GPU) requires use of parallelisation.
\item  Parallelisation inclides vectorisation, which is much hader to achieve.
\item  CPU can be progremed in similar way as GPU, altoght they lack several important vector instructions. 
\item Those instructions are probably introduced in Xeon $\phi$.
\end{itemize}
\end{frame}


\end{document}
